================================================================================
statements of expressions
================================================================================

{erl_opts, [warnings_as_errors]}.
ok.
error.

--------------------------------------------------------------------------------

(source
  (tuple
    (atom)
    (list
      (atom)))
  (atom)
  (atom))

================================================================================
function declarations
================================================================================

ok_this(Term) -> {ok, Term}.

factorial(N) when N>0 ->
    N * factorial(N - 1);
factorial(1) -> 0.

do_effects(Effects) ->
    Effects1 = do_effects1(Effects),
    do_effects2(Effects1).

--------------------------------------------------------------------------------

(source
  (function
    (atom)
    (arguments
      (variable))
    (tuple
      (atom)
      (variable)))
  (function
    (atom)
    (arguments
      (variable))
    (guard
      (binary_operator
        (variable)
        (integer)))
    (binary_operator
      (variable)
      (call
        (atom)
        (arguments
          (binary_operator
            (variable)
            (integer)))))
    (atom)
    (arguments
      (integer))
    (integer))
  (function
    (atom)
    (arguments
      (variable))
    (body
      (binary_operator
        (variable)
        (call
          (atom)
          (arguments
            (variable))))
      (call
        (atom)
        (arguments
          (variable))))))

================================================================================
statement flexibility with newlines
================================================================================

%% Without the newline choice in the statement rule, the second call would
%% be misparsed.
hd([a]),
tl([a])
maps:get(date,DateTime).

--------------------------------------------------------------------------------

(source
  (comment)
  (comment)
  (call
    (atom)
    (arguments
      (list
        (atom))))
  (call
    (atom)
    (arguments
      (list
        (atom))))
  (call
    (atom)
    (atom)
    (arguments
      (atom)
      (variable))))

================================================================================
specs
================================================================================

-spec ok_this(term()) -> {ok, term()}.
-callback after(Reason :: atom()) -> ok.

--------------------------------------------------------------------------------

(source
  (attribute
    (atom)
    (stab_clause
      (atom)
      (arguments
        (call
          (atom)
          (arguments)))
      (tuple
        (atom)
        (call
          (atom)
          (arguments)))))
  (attribute
    (atom)
    (stab_clause
      (atom)
      (arguments
        (binary_operator
          (variable)
          (call
            (atom)
            (arguments))))
      (atom))))

================================================================================
spec with when clause
================================================================================

-spec function(Arg) -> Result when
      Result :: any().

--------------------------------------------------------------------------------

(source
  (attribute
    (atom)
    (stab_clause
      (atom)
      (arguments
        (variable))
      (variable))
    (guard
      (binary_operator
        (variable)
        (call
          (atom)
          (arguments))))))

================================================================================
attributes
================================================================================

-module(ok).
-include("records.hrl").
-export([ok_this/1]).
-dialyzer({nowarn_function, [ok_this/1]}).
-ifdef(debug).
-define(LOG(X), io:format("~80p~n", [X])).
-else.
-define(LOG(X), _ = X).
-endif.
-if(?DEBUG).

--------------------------------------------------------------------------------

(source
  (attribute
    (atom)
    (arguments
      (atom)))
  (attribute
    (atom)
    (arguments
      (string
        (quoted_content))))
  (attribute
    (atom)
    (arguments
      (list
        (binary_operator
          (atom)
          (integer)))))
  (attribute
    (atom)
    (arguments
      (tuple
        (atom)
        (list
          (binary_operator
            (atom)
            (integer))))))
  (attribute
    (atom)
    (arguments
      (atom)))
  (attribute
    (atom)
    (arguments
      (call
        (variable)
        (arguments
          (variable)))
      (call
        (atom)
        (atom)
        (arguments
          (string
            (quoted_content))
          (list
            (variable))))))
  (attribute
    (atom))
  (attribute
    (atom)
    (arguments
      (call
        (variable)
        (arguments
          (variable)))
      (binary_operator
        (variable)
        (variable))))
  (attribute
    (atom))
  (attribute
    (arguments
      (macro
        (variable)))))

================================================================================
type declarations
================================================================================

-type arity() :: non_neg_integer().
-type integer() :: neg_integer()
                   | 0
                   | pos_integer().
-type mylist() :: [integer(), ...].

--------------------------------------------------------------------------------

(source
  (attribute
    (atom)
    (arguments
      (binary_operator
        (call
          (atom)
          (arguments))
        (call
          (atom)
          (arguments)))))
  (attribute
    (atom)
    (arguments
      (binary_operator
        (call
          (atom)
          (arguments))
        (binary_operator
          (binary_operator
            (call
              (atom)
              (arguments))
            (integer))
          (call
            (atom)
            (arguments))))))
  (attribute
    (atom)
    (arguments
      (binary_operator
        (call
          (atom)
          (arguments))
        (list
          (call
            (atom)
            (arguments)))))))

================================================================================
macro declarations
================================================================================

-define(MIN(X, Y), if X < Y -> X; true -> Y end).

--------------------------------------------------------------------------------

(source
  (attribute
    (atom)
    (arguments
      (call
        (variable)
        (arguments
          (variable)
          (variable)))
      (if
        (clause
          (binary_operator
            (variable)
            (variable))
          (variable))
        (clause
          (atom)
          (variable))))))

================================================================================
record definitions
================================================================================

-record(person, {name = "a" :: string(), age = 0 :: non_neg_integer()}).

--------------------------------------------------------------------------------

(source
  (attribute
    (atom)
    (arguments
      (atom)
      (tuple
        (binary_operator
          (binary_operator
            (atom)
            (string
              (quoted_content)))
          (call
            (atom)
            (arguments)))
        (binary_operator
          (binary_operator
            (atom)
            (integer))
          (call
            (atom)
            (arguments)))))))
