================================================================================
function calls
================================================================================

self()
hd([a])
tl([a])
maps:get(date,DateTime)
(fun (X) -> X end)(1)

--------------------------------------------------------------------------------

(source
  (call
    (atom)
    (arguments))
  (call
    (atom)
    (arguments
      (list
        (atom))))
  (call
    (atom)
    (arguments
      (list
        (atom))))
  (call
    (atom)
    (atom)
    (arguments
      (atom)
      (variable)))
  (call
    (anonymous_function
      (stab_clause
        (arguments
          (variable))
        (variable)))
    (arguments
      (integer))))

================================================================================
blocks
================================================================================

begin
  _ = 1 + 1,
  _ = 2 + 2
end

--------------------------------------------------------------------------------

(source
  (block
    (binary_operator
      (variable)
      (binary_operator
        (integer)
        (integer)))
    (binary_operator
      (variable)
      (binary_operator
        (integer)
        (integer)))))

================================================================================
comprehensions
================================================================================

%% Comprehensions are parsed very simply by treating '||' as a (right-assoc)
%% binary operator.
%% We could structure this rule more and make syntax assertions about the
%% generator(s) and qualifier(s) but I don't really see a point.
[ X * 2 || X <- [1, 2, 3]]
<< << (X * 2) >> || << X >> <= << 1, 2, 3 >> >>

--------------------------------------------------------------------------------

(source
  (comment)
  (comment)
  (comment)
  (comment)
  (list
    (binary_operator
      (binary_operator
        (binary_operator
          (variable)
          (integer))
        (variable))
      (list
        (integer)
        (integer)
        (integer))))
  (bitstring
    (binary_operator
      (binary_operator
        (bitstring
          (binary_operator
            (variable)
            (integer)))
        (bitstring
          (variable)))
      (bitstring
        (integer)
        (integer)
        (integer)))))

================================================================================
if
================================================================================

if
  X > Y -> X;
  X =< Y -> Y
end

--------------------------------------------------------------------------------

(source
  (if
    (clause
      (binary_operator
        (variable)
        (variable))
      (variable))
    (clause
      (binary_operator
        (variable)
        (variable))
      (variable))))

================================================================================
case
================================================================================

case Var of
  {ok, X} when is_integer(X) -> X;
  {error, Reason} -> {error, Reason}
end

--------------------------------------------------------------------------------

(source
  (case
    (variable)
    (clause
      (tuple
        (atom)
        (variable))
      (guard
        (call
          (atom)
          (arguments
            (variable))))
      (variable))
    (clause
      (tuple
        (atom)
        (variable))
      (tuple
        (atom)
        (variable)))))

================================================================================
receive
================================================================================

receive
  ok ->
    ok;
  timeout ->
    error
end.

receive
  ok ->
    ok
after
  5_000 -> error
end.

receive
after
  0 -> ok
end.

--------------------------------------------------------------------------------

(source
  (receive
    (clause
      (atom)
      (atom))
    (clause
      (atom)
      (atom)))
  (receive
    (clause
      (atom)
      (atom))
    (after
      (integer)
      (atom)))
  (receive
    (after
      (integer)
      (atom))))

================================================================================
unary operators
================================================================================

-1,
-2.3e-3,
not true,
-1 + 2,
2 + -1,
false or not true.

--------------------------------------------------------------------------------

(source
  (unary_operator
    (integer))
  (unary_operator
    (float))
  (unary_operator
    (atom))
  (binary_operator
    (unary_operator
      (integer))
    (integer))
  (binary_operator
    (integer)
    (unary_operator
      (integer)))
  (binary_operator
    (atom)
    (unary_operator
      (atom))))

================================================================================
macros
================================================================================

?MODULE,
#?MODULE{},
?MIN(2, 3).

--------------------------------------------------------------------------------

(source
  (macro
    (variable))
  (record
    (macro
      (variable)))
  (macro
    (variable)
    (arguments
      (integer)
      (integer))))
