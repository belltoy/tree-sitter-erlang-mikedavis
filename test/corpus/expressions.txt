================================================================================
function calls
================================================================================

self()
hd([a])
tl([a])
maps:get(date,DateTime)
(fun (X) -> X end)(1)

--------------------------------------------------------------------------------

(source
  (call
    (atom)
    (arguments))
  (call
    (atom)
    (arguments
      (list
        (atom))))
  (call
    (atom)
    (arguments
      (list
        (atom))))
  (call
    (atom)
    (atom)
    (arguments
      (atom)
      (variable)))
  (call
    (anonymous_function
      (stab_clause
        (arguments
          (variable))
        (variable)))
    (arguments
      (integer))))

================================================================================
blocks
================================================================================

begin
  _ = 1 + 1,
  _ = 2 + 2
end

--------------------------------------------------------------------------------

(source
  (block
    (binary_operator
      (variable)
      (binary_operator
        (integer)
        (integer)))
    (binary_operator
      (variable)
      (binary_operator
        (integer)
        (integer)))))

================================================================================
comprehensions
================================================================================

%% Comprehensions are parsed very simply by treating '||' as a (right-assoc)
%% binary operator.
%% We could structure this rule more and make syntax assertions about the
%% generator(s) and qualifier(s) but I don't really see a point.
[ X * 2 || X <- [1, 2, 3]]
<< << (X * 2) >> || << X >> <= << 1, 2, 3 >> >>

--------------------------------------------------------------------------------

(source
  (comment)
  (comment)
  (comment)
  (comment)
  (list
    (binary_operator
      (binary_operator
        (binary_operator
          (variable)
          (integer))
        (variable))
      (list
        (integer)
        (integer)
        (integer))))
  (bitstring
    (binary_operator
      (binary_operator
        (bitstring
          (binary_operator
            (variable)
            (integer)))
        (bitstring
          (variable)))
      (bitstring
        (integer)
        (integer)
        (integer)))))

================================================================================
if
================================================================================

if
  X > Y -> X;
  X =< Y -> Y
end

--------------------------------------------------------------------------------

(source
  (if
    (if_clause
      (binary_operator
        (variable)
        (variable))
      (variable))
    (if_clause
      (binary_operator
        (variable)
        (variable))
      (variable))))

================================================================================
case
================================================================================

case Var of
  {ok, X} when is_integer(X) -> X;
  {error, Reason} -> {error, Reason}
end

--------------------------------------------------------------------------------

(source
  (case
    (variable)
    (case_clause
      (tuple
        (atom)
        (variable))
      (call
        (atom)
        (arguments
          (variable)))
      (variable))
    (case_clause
      (tuple
        (atom)
        (variable))
      (tuple
        (atom)
        (variable)))))
